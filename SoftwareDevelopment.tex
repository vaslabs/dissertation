\chapter{Software development}
\label{softD}
The software development process involved implementing simulations for the mathematical models described in Chapter \ref{morphogenesis}, 
testing that involved a basic mathematical analysis of each model and documentation of the work.
The methodologies that were followed during the project can be used as a reference for the reader in order to follow or improve such a method for future research or a related project. It can also be used as a method of understanding the coding structure and then expanding the ideas that are introduced in this project.

\section{Model simulations}
The main deliverable concerning model simulations is a Matlab application. The methodology is discussed to help the reader in using the application and its source code. It might also be used as a guide for solving similar problems.  

\subsection{Code structure}
The code has three main components:
\begin{itemize}
\item The main function that prompts the user to initialise certain parameters of the model, such as the number of cells and the amount of time to be used in integrating the equations.
\item A nested function in the body of the main function that calculates the equations of a certain model. Whether it can be uncoupled from the main function is debatable; it is easier to share variables from the main function to the nested one.
\item Global external functions that can be used by any application and can be easily imported by anyone who is interested in using them. Examples of such functions are the \texttt{playMovie} and \texttt{scaleColors}.
\end{itemize}
Globally available functions are shown in appendix\ref{App:AppendixA}.


\subsection{Testing}

Testing mathematical models is challenging. In general, software testing is done by comparing the output of a body of code with hard-coded data (that is, the expected output). For testing a mathematical model, an analysis of that model needs to be done first, in order to identify what behaviour is expected. The analysis can be automated with the use of the symbolic computational capabilities of Matlab \cite{MATLAB_2010} or Mathematica \cite{mathematica}.

Testing of function implementation that do not involve integration of a system of equations is done in a traditional approach; the output results of a function for certain inputs are compared to expected outputs for those input values. 
The \texttt{scaleColors} function is a crucial function to the system, since it is a key part in mapping the morphogen concentrations to color interpreted values. It takes an array of morphogen concentrations and normalises their values to the range of $[0,1]$ according to the maximum and minimum concentrations. 
%An example of the testing procedure on this function is provided on the table x below. %TODO

%TODO put table here
\subsection{Documentation}

Documentation of the work is presented in HTML format. The purpose of documenting the Matlab functions is to provide a quick reference of the functions implemented, their arguments and their interdependence. 
In order to automate the process of documentation a Bash script was created that gets a set of Matlab files and creates HTML files that provide information of the functions in each file (see bash scripts \ref{matdocpages} and \ref{matdoc}). 

\section{Process scheduling}

The deliverable is a framework written in Java that can be used for:
\begin{enumerate}
\item Creating Scheduler algorithms.
\item Implementing ODE solvers.
\item Defining mathematical models.
\item Running and retrieving statistical results for each scheduler.
\end{enumerate}
An additional tool written in bash script and gnuplot script is provided for converting the statistical information generated by the Java implementation into bar graphs. All scripts can be found in Appendix \ref{App:AppendixC}. %TODO other helpful scripts
%TODO put Appendix 

\subsection{Methodology}
The framework is meant to be used by anyone that wants to experiment with the idea of scheduling by solving differential equations. Thus, the use of software design patterns was essential in order to make the code readable and easy to be expanded. Documentation was generated with proper commenting of the code and then the use of \texttt{javadoc} \cite{javadoc} and testing was done with graph generation by using gnuplot scripts.

\subsection{Code structure}
All class files are included in a single package. The naming of the files is based on software design patterns. Testing was done by the use of bash scripts and the use of the test class "TestScheduler" for the schedulers. The graphs for analysing the effectiveness of each algorithms were generated with the program gnuplot and bash scripts to create data files for the gnuplot scripts.  

\subsubsection{Software design patterns}
A fair amount of software design patterns were used in order to make the code more readable and easier to maintain. %TODO
The patterns were used in reference of the `Gang of Four' \cite{gamma_design_1998} and GRASP \cite{larman_applying_2004}.

The Template pattern was used to protect variations among various ODE solvers, equations/functions and schedulers. A default implementation is given by either an interface or an abstract class and every class-object that provides a specific implementation extends that interface or abstract class. This helps in extending the framework with more ode solvers, schedulers or mathematical models.

A Memento pattern is used for the process classes, allowing them to restore to their initial state and be reused different schedulers. This helps in the statistical analysis, because schedulers must be compared to each other under the same circumstances. For instance, a process is created with random properties such as how many time cycles are needed to finish at which points in time it blocks or crashes etc. All process properties are shown in Figure \ref{processfigure}.

 
\subsection{Testing}
Testing was done by producing graph plots and bar graphs in order to observe abnormalities in the parameters of the processes or schedulers. Abnormalities were expected by the use of wrong time step in the Euler's method implementation or bugs in general that restricted the program to run according to its requirements.
The graphs and plots were generated with gnuplot with a middle layer script written in bash. The role of the script was to convert the data of the scheduler statistics into gnuplot data format.

\section{Scripts and tools}
A set of scripts were implemented in order to automate the process of testing, documentation and statistical analysis of the scheduling solutions. All scripts were written in Bash on a Linux based operating system. In addition, gnuplot was used in order to import data and generate graphs to visualise the statistical results.
The decision for implementing separated scripts to automate the tasks described was proved to have a significant positive impact during the project development. Each script and its role is shown in Table \ref{scripttable}.

\begin{table}
\begin{center}
\begin{tabular}{| c | c | p{10cm} | c |}
\hline
File-name & Language & Description & Source-code \\ \hline
matdoc & Bash & Reads a matlab file that contains and creates a representative HTML file that contains the functions defined in the matlab file. Each function is given a description according to the comments it has before its definition. & \ref{matdoc} \\ \hline

matdoc\_pages & Bash & Gets all HTML files and outputs an HTML body containing a list of links for those files. If its output is piped to a file called index, the whole documentation is ready to be read. & \ref{matdocpages} \\ \hline
run-test & Bash & Executes the TestScheduler class of the process scheduling solution with a given argument that represents the number of processes existing initially in the queue and then, converts the output data into data that can be read by gnuplot script. & \ref{runtest} \\ \hline

run-tests & Bash & Gets 3 arguments: number of processes to start, number of processes to finish and the step to reach that number of processes. Then it calls run-tests and gets the generated data to plot them using the gnuplot script totalTime.p & \ref{runtests} \\ \hline

totalTime.p & gnuplot & Reads a data file and generates the bar plots to visualise the results as shown in paragraph \ref{sca}. & \ref{totaltime} \\ \hline
\end{tabular}
\end{center}
\caption{Description of the implemented scripts that automate documentation and testing.}
\label{scripttable}
\end{table}
